# libraries
import pandas as pd
import os
import gzip
import re # for regular expressions
import numpy as np
import json
from snakemake.utils import min_version

min_version("7.15.2")

module_name = "genome_tracks"

##### setup report #####
report: os.path.join("report", "workflow.rst")

##### set & load config and sample annotation sheets #####
configfile: os.path.join("config","config.yaml")

annot = pd.read_csv(config['sample_annotation'])
gene_dict = pd.read_csv(config['gene_list'], index_col="gene_region").to_dict('index')
genes = list(gene_dict.keys())

# groups for bam file merging
merge_groups = sorted(annot['group'].unique())

# extracts unique grouping values from the 2nd column of the single cell metadata TSV files listed in 'group' column of annotation file
sc_file_group_dict = {}
for f in annot['group']:
    if f.endswith('.tsv'):
        sc_file_group_dict[f] = pd.read_csv(f, header=None, sep='\t')[1].unique().tolist()
sc_groups = list(set(value for sublist in sc_file_group_dict.values() for value in sublist))

# groups for actual visualization
plot_groups = list(set(sc_groups + [f for f in annot['group'] if not f.endswith('.tsv')]))

print(merge_groups)
print(sc_groups)
print(plot_groups)

result_path = os.path.join(config["result_path"], module_name)

COORD_REGEX = re.compile('chr[0-9XY]+:[0-9]+-[0-9]+$')

##### load rules #####
include: os.path.join("rules", "common.smk")
include: os.path.join("rules", "envs_export.smk")
include: os.path.join("rules", "prepare.smk")
include: os.path.join("rules", "visualization.smk")

# find gtrack parameters for each gene and handle exception when gene is not found
gene_annot_list = []
remove_genes = []
for gene in genes:
    if COORD_REGEX.match(gene):
        gene_annot_list.append((parse_region(gene) + (gene_dict[gene]["ymax"],)))
    else:
        tmp_val = parse_gene(gene)
        if tmp_val==-1:
            # drop gene, because not found
            remove_genes.append(gene)
        else:
            gene_annot_list.append((tmp_val + (gene_dict[gene]["ymax"],)))

# save text file containing genes that were not found in the provided genome BED file
if len(remove_genes)>0:
    if not os.path.exists(os.path.join(config["result_path"],'genome_tracks')):
        os.makedirs(os.path.join(config["result_path"],'genome_tracks'))
    pd.DataFrame(remove_genes).to_csv(os.path.join(config["result_path"],'genome_tracks','genes_not_found.csv'), index=False, header=False)
    genes = [gene for gene in genes if gene not in remove_genes]

genes = [gene.replace(':', '-') for gene in genes]
gene_annot_df = pd.DataFrame(gene_annot_list, columns=['chr', 'start', 'end', 'count', 'ymax'], index=genes)

# print(gene_annot_df)

##### target rule #####
rule all:
    input:
        # preparation
        merged_bams = expand(os.path.join(result_path, 'merged_bams','{group}.bam'), group=merge_groups),
        sc_bams = expand(os.path.join(result_path, 'sc_bams','{group}.bam'), group=sc_groups),
        # genome tracks
        genome_tracks = expand(os.path.join(result_path, 'tracks', '{gene}.'+config["file_type"]), gene=genes),
#         genome_tracks_all = expand(os.path.join(result_path, 'tracks', 'ALL_{gene}.'+config["file_type"]), gene=genes),
        # UCSC genome browser track hub
        trackdb_file = os.path.join(result_path, "bigWigs", config["genome"], "trackDb.txt"),
        # IGV-report
        igv_report = os.path.join(result_path, "igv-report.html"),
        # environments and configs
        envs = expand(os.path.join(config["result_path"],'envs', module_name,'{env}.yaml'),env=['pygenometracks','igv_reports']),
        gene_list = os.path.join(config["result_path"],'configs', module_name,'gene_list.txt'),
        configs = os.path.join(config["result_path"],'configs', module_name,'{}_config.yaml'.format(config["project_name"])),
        annotations = os.path.join(config["result_path"],'configs', module_name,'{}_annot.csv'.format(config["project_name"])),
    params:
        # cluster parameters
        partition = config.get("partition"),
    resources:
        mem_mb=config.get("mem", "4000"),
    threads: config.get("threads", 1)
    log:
        os.path.join("logs","rules","all.log")
